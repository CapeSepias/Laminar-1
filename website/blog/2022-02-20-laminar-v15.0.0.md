---
title: Laminar v15.0.0
author: Nikita
authorURL: http://twitter.com/raquo
---

TODO TODO TODO 

<!--truncate-->



## News

TODO
TODO
TODO
TODO
TODO - Version bump
TODO - Distinct methods

>>> Is it a good idea to automatically de-duplicate data sent to Laminar DOM?? How do we force DOM update? Maybe we should disable this for now?
>>> TODO I think we need to disable auto-distinction, at least in props?

>>> remove composeDistinct from splitOne – use identity for no distinction?

>>> AjaxStream needs an emitOnce option that defaults to false?



## New Laminar Features



### Improved Performance

I started using my new library **[ew](https://github.com/raquo/ew)** to get consistently fast implementations of methods like `indexOf` and `forEach` on JS types. This brings several orders of magnitude big performance improvements when rendering very large lists of children (thousands or tens of thousands of items). There were other internal changes too, but this takes the cake in terms of impact. Most of this was actually done in 0.14.2, but I didn't have time to write a blog post just for that.

If you're interested in this problem as a Scala.js library author, check out **ew**'s README and see [this bug](https://github.com/raquo/Laminar/issues/108) as a practical example.



### `flatMap` and `compose` for DOM events 

Typically, you subscribe to DOM events without explicitly creating any streams. This is simple and convenient, but it lacks the full palette of observables operators. We already had two ways to access those fancy operators in Laminar:

```scala
div(
  onClick.delay(1) --> observer, // does not compile
  inContext(_.events(onClick).delay(1) --> observer),
  composeEvents(onClick)(_.delay(1)) --> observer
)
```

This `composeEvents` method always rubbed me the wrong way because it's not discoverable – you can't find it via autocomplete after typing `onClick.`. Something prevented me from doing this earlier, but now I've realized that I can offer equivalent functionality as an `onClick.compose` method which works just like the observables' native `compose` method:

```scala
div(
  onClick.compose(_.delay(1)) --> observer,
  onClick
    .preventDefault
    .map(getFoo)
    .compose(_.filter(isGoodFoo).startWith(initialFoo)) --> observer,
)
```

I've also added a new `flatMap` method which is useful when you want to create a new observable on every DOM event. For example:

```scala
def makeAjaxRequest(): EventStream[Response] = ???

input(
  onInput
    .mapToValue
    .flatMap(txt => sendAjaxRequest(txt)) --> observer
)
```

If you use this new `flatMap` method in IntelliJ IDEA, you'll be annoyed to find that it causes the IDE to incorrectly report a fake type error. Not holding my breath for this being fixed, so I had to bastardize the API by adding more specialized `flatMapStream` and `flatMapSignal` methods which don't trigger the fake error in the IDE.

Between `flatMap` and `compose`, obtaining observables' functionality from DOM events is much more natural now, so `composeEvents` is now deprecated. **Migration** is trivial: rewrite `composeEvents(a)(b)` to `a.compose(b)`.



### Easier Integration With Third Party DOM Elements

Previously you could only use low level methods to inject foreign elements into the Laminar element tree. Now if some JS library gives you a DOM element, you can wrap it in Laminar goodness and use it like any other Laminar element, including adding event listeners and dynamically updating its properties:

```scala
def getThirdPartyMapWidget(): dom.html.Element = ???

div(
  foreignHtmlElement(getThirdPartyMapWidget()),
  // And this is how you add modifiers in the same breath:
  foreignHtmlElement(getThirdPartyMapWidget()).amend(
    onMountCallback {
      thirdPartyLibraryInitMap()
    },
    onClick --> someObserver,
    onResize --> someOtherObserver
  ),
)
```

A similar `foreignSvgElement` helper is available for SVGs.

I've also added `unsafeParseSvgString(dangerousSvgString: String): dom.svg.Element` to help render SVG strings. It requires two steps, but that inconvenience is by design for such an unsafe API:

```scala
div(
  foreignSvgElement(DomApi.unsafeParseSvgString("<svg>....</svg>")),
  // And similarly for HTML elements:
  foreignHtmlElement(DomApi.unsafeParseHtmlString("<div onclick="alert('pwned')"></div>"))
)
```

These unsafe methods expose you to [XSS attacks](https://owasp.org/www-community/attacks/xss/) so you should not run them on untrusted strings.

All these new methods have a few variations for different use cases, you'll find them when needed.



### CSS API Improvements

#### Unit and function helpers

Previously if you wanted to set a pixel value to a CSS style prop, you would need to append "px" or some other unit to your desired number. That's annoying, and with observables it might require the overhead of creating another observable with `.map(s"${_}px")`.

You can still do it the old way, but the new API offers several ways to set style values in units like `px`, `vh`, `percent`, `ms`, etc.:

```scala
div(
  margin.px := 12,
  marginTop.px := 12,
  marginTop.px(12), // remember that all `:=` methods in Laminar are aliased to `apply` for convenience!
  marginTop.calc("12px + 50%"),
  marginTop.px <-- streamOfInts,
  marginTop.px <-- streamOfDoubles
)
```

The new API is type-safe, so for example `backgroundImage.px` does not exist, but `.url` does:

```scala
div
  // Equivalent to CSS:  background-image: url("https://example.com/image.png")
  backgroundImage.url := "https://example.com/image.png"),
  backgroundImage.url("https://example.com/image.png"), // same
  backgroundImage.url <-- streamOfUrls
)
```

I haven't decided how to treat some of the more complex composite CSS properties yet, so some of them still only accept strings, which means that you can do `borderWidth.px := 12` but can't do `border.px := 12` yet. But you can use the new `style` string helpers: `style.px(12)` returns a plain "12px" string which you can use like `border := style.px(12)`.

#### Get string values from style keyword setters

You could already use keyword shorthands like `display.none` – that modifier is equivalent to `display := "none"` – and now you can also get string constants from these shorthands with their newly exposed `value` property:

```scala
div(
  // Before
  textAlign <-- streamOfBooleans.map(
    if (_) "left" else "right"
  ),
  // After – same, but you get to marvel at your IDE knowing these symbols
  textAlign <-- streamOfBooleans.map(
    if (_) textAlign.left.value else textAlign.right.value
  )
)
```

Want a bit less boilerplate? Define a trivial implicit conversion from `StyleSetter[String]` to `String`, and you won't need to call `.value` manually. This is a bit too magicky for Laminar core though.

#### Vendor prefixes

Not super relevant feature these days, but you can now do this to set a style property along with several prefixes:

```scala
div(
  transition.withPrefixes(_.moz, _.ms, _.webkit) := "all 4s ease"
  // and similarly for <--
)
```



## New Airstream Semantics


### No More `==` Checks in Signals

Prior to this release, an Airstream Signal would skip emitting a value that is `==` equal to its current state. For example, if you had `val signal = stream.startWith(0)` and `stream` emitted event `1` twice in a row, `signal` would not emit `1` the second time, because the value of the state that it represents didn't actually change. This behaviour was supposed to deduplicate / declutter signal updates and overall better serve the "state" semantic of Signals, but ultimately it caused more issues than it solved.

On a practical level, some `==` checks could be expensive when they evaluate structural equality (e.g. of large collections like lists or maps). And this work is performed on every event and at every signal operator, every time you `map` / `filter` / etc. that data. And then when you hand over the result to `children <--`, the diffing algorithm essentially does the same job again.

Worst of all, there wasn't really a good way to disable this behaviour. You would need to either use streams, or wrap your data in useless types like `class Ref[A](val v: A)` whose only job is to force comparison by reference equality.

??? ... To account for this, Laminar now performs automatic deduplication where observables meet the DOM. For example, if you have `a(href <-- signal)`, and `signal` emits `hello` twice, the input's `href` property will only be updated to `hello` once.

TODO I think we should disable auto-distinction

In Airstream 15.0.0 signals no longer perform `==` checks, they emit every event just like streams. This makes all observables' behaviour more uniform, eliminating `==` checks as a decision factor when choosing the data type.

#### New `distinct*` operators

Both streams and signals now have various `distinct*` operators to enable `==` or other conditional checks as needed. These can be used to make your signals behave like they did prior to the update, or achieve different, custom logic:

```scala
signal.distinct // performs `==` checks, similar to pre-15.0.0 behaviour
signal.distinctByRef // performs reference equality checks
signal.distinctByKey(_.id) // performs `==` checks on a certain key
signal.distinctBy((prevValue, nextValue) => isSame) // custom checks
signal.distinctErrors((prevErr, nextErr) => isSame) // for the error channel
signal.distinctTry((prevTryValue, nextTryValue) => isSame) // one comparator for both event and error channels
```

The same operators are available on streams too.

#### `split` operator distinction

The `split` operator internally uses `==` checks to determine whether each record in the collection has changed or not, and decided whethher to emit that updated record to the right child-specific stream (or signal). If not for these checks, `split` would trigger many useless updates for children that were not actually affected by the latest event.

To maintain this behaviour, the `split` operator now has a second parameter called `distinctCompose` which indicates how exactly the values are to be distinct-ed, and defaults to `_.distinct`, for `==` equality. You can override it to provide a custom distinctor function if desired:

```scala
children <-- nodesStream.split(_.id, _.distinctBy(customComparator))(...)
```

**Migration:** 

The most straightforward solution is to call `distinct` on any Signal that you want to behave like it used to. The challenge is to find which signals need such treatment – a manual review is required, there is no way around it. I suggest focusing on the following cases:

* Any place where you _know_ that you relied on signals performing `==` checks.
* Signals that drive side effects, such as making network requests or updating `Var`-s in non-idempotent ways.
* Observables or Vars that accumulate values from some input, e.g. `observable.foldLeft(...)((acc, next) => newAcc)` – if `observable` is a signal, or a stream that depends on a signal, it might be emitting more events now than before.
* `flatMap` and `flatten` calls that might involve per-event side effects.
* Any state logic that is complex for any reason.

During this migration, adding an extraneous `.distinct` is rather unlikely to cause breakage, so if you're not quite sure about some suspicious signal, you can start by `.distinct`-ing it, and try undoing it later as time allows.


### Signals Now Try to Re-sync After Restarting

This is a solution to [#43](https://github.com/raquo/Airstream/issues/43). Suppose we have:

```scala
val parentSignal: Signal[Foo] = ???
val childSignal: Signal[Bar] = parentSignal.map(fooToBar)

span(
  backgroundColor <-- childSignal.map(bar => bar.color)
)
```

Since `childSignal`'s value is very explicitly derived from `parentSignal`'s value, you generally expect their values to be in sync at all times. And this is true as long as both signals are **started**, that is, have observers. However, `childSignal` can become **stopped** if it loses all of its observers, e.g. if this `span(...)` was to be unmounted.

If this happens, `childSignal` will stop listening to `parentSignal` (observables are lazy), and if `parentSignal` does not get stopped at the same time (it might have other observers), `parentSignal`'s value might be updated while `childSignal` is not listening.

This would become a problem when `childSignal` is re-started again, e.g. because you decided to mount that same `span(...)` again. Until Airstream 15.0.0, doing that would cause `childSignal` to be out of sync with `parentSignal` because it missed the parent's update while it was stopped. In Airstream 15.0.0, `childSignal` now "pulls" the parent's latest value when re-starting, and updates its own value to match (calling `fooToBar` in this case).

**CAVEAT: Note that when restarting `childSignal`, `fooToBar` will be called regardless of whether `parentSignal`'s value actually changed or not while `childSignal` was stopped. I am rather annoyed at this caveat, because it means that starting with 15.0.0, the callback provided to the signal's `map` operator can potentially be run more than one time for the same event / value, just because the signal is being stopped and re-started. That means that the callback has to be free of side effects now. And it's this way for almost all signals. In contrast, even in 15.0.0 the `foldLeft` signal keeps track of last seen parent value and does not trigger its increment callback if the parent's value is the same (`==`) on restart. I think this part of the semantic changes deserves a second look, maybe we should try to implement `foldLeft`-like logic on all signals. I do NOT like ingraining `==` checks into a different aspect of the library after we've just gotten rid of them, but this might be the lesser of two evils. Ideas / feedback welcome!**

This new technique keep signals synced with each other pretty well, but it's not perfect. For example, if you have `signal = parentStream.startWith(1)`, your `signal` can't "pull" any updates it missed from `parentStream` because unlike signals, streams don't have a "current value" and don't "remember" their last emitted event, if you miss a stream event, you're not getting it back.

* Note: this pulling / re-syncing behaviour is generally for signals only, not streams. For example if you have `childStream = signal.changes`, and childStream gets stopped and then restarted later after some time, it will not emit `signal`'s new current value. This matches pre-15.0.0 behaviour, but this fact is more important now.

TODO TODO TODO


### Observables No Longer Reset Their Internal State When Stopped

Until this new Airstream version, our design generally assumed that when an observable is stopped, the user would want to clear / reset its state. Combined with source observables like `EventStream.fromValue(v)` and `AjaxEventStream` defaulting to `emitOnce = false`, that is, re-emitting their events on **every** start, this was a reasonable way to approach the problem of properly reviving Laminar components after they have been unmounted and mounted again.

As a concrete example, in past Airstream versions, after `stream1.combineWith(stream2)` was restarted, it would not start emitting events again until **both** stream1 and stream2 emitted a new event, because when the combined stream was stopped, it "forgot" the previous events that its parent streams emitted.

So in that example, if your `stream1` and `stream2` streams also re-emitted during this restart, everything would be fine, the combined stream would emit the new combined event, and you would get the expected result. However, Not all streams behaved that way, and so this restarting paradigm was not always helpful.

The new restarting paradigm is pretty much the opposite – the observables generally remember their last known state if stopped, and signals even try to re-sync their state when they're started again. On the other hand, source observables like `EventStream.fromValue(v)` and `AjaxEventStream` now default to `emitOnce = true`, that is, they don't re-run their logic every time they're started, only the **first** time.


That behaviour was part of a general idea of 


TODO
TODO
TODO
TODO



## New Airstream Features


### New `take` and `drop` operators

The new `stream.take(numEvents)` operator returns a stream that re-emits the first `numEvents` events emitted by the parent `stream`, and then stops emitting. `stream.drop(numEvents)` does the opposite, skipping the first `numEvents` events and then starting to re-emit everything that the parent `stream` emits.

These operators are available with several signatures:

```scala
stream.take(numEvents = 5)
stream.takeWhile(ev => passes(ev)) // stop taking when `passes(ev)` returns `false`
stream.takeUntil(ev => passes(ev)) // stop taking when `passes(ev)` returns `true`
```

```scala
stream.drop(numEvents = 5)
stream.dropWhile(ev => passes(ev)) // stop skipping when `passes(ev)` returns `false`
stream.dropUntil(ev => passes(ev)) // stop skipping when `passes(ev)` returns `true`
```

Like many other operators, these have an optional `resetOnStop` argument. Defaults to `false`, but if set to `true`, they "forget" everything and are reset to their original state after the parent stream is stopped and then started again.


### New `filterWith` operator

`stream.filterWith(signalOfBooleans)` emits only when the given signal's (or Var's) current value is `true`.

Can be used with Laminar's new `compose` method to filter DOM events too: 

```scala
div(onClick.compose(_.filterWith(clickEnabledVar)) --> observer)
```


### New `collectSome`, `collectOpt` operators

`(stream: EventStream[Option[A]]).collectSome` returns an `EventStream[A]`.

`collectOpt` is similar: `def collectOpt[B](fn: A => Option[B]): EventStream[B]`, useful for methods like `NonEmptyList.from(list): Option[NonEmptyList]`.


### New `EventStream.after(ms)` shorthand

`EventStream.after(ms, optionalValue)` emits `optionalValue` (or `()` if omitted) `ms` milliseconds after the stream is started. Useful to delay some action after the component is mounted, e.g.:

```scala
div(
  EventStream.after(5000) --> showBullshitMarketingPopup
)
```


### New: Signal.fromFuture with initial value

`Signal.fromFuture(future)` produces a `Signal[Option[A]]` which you can work around, but is annoying. Now you can specify `initialValue: A` as the second argument, and get a `Signal[A]` that will start with that value if the `future` is not yet resolved. 


### New: Flatten streams of signals

We now have a FlattenStrategy that supports this particular combination of observables before. You can do that now: `stream.flatMap(v => makeFooSignal(v))` returns `EventStream[Foo]`, and works similar to switching streams. 


### New `throwFailure` operator

Turns `Observable[Try[A]]` into `Observable[A]`, moving the failure into the error channel. From when you want to un-recover from `recoverToTry`.



## Changes to `scala.Future` integration 

Airstream lets you create streams and signals from scala Futures and JS promises. Future based functionality is now implemented using `js.Promise`, instead of the opposite, to avoid surprising behaviour in some edge cases.

This means that if you don't use Futures but use JS Promises, your code is now scala.Future-free, and your JS bundle should get slimmer as a result (unless your other dependencies still use Futures). This also means that Future-based streams have a few milliseconds of extra latency now as the futures need to be translated to js.Promise. Since they're asynchronous by nature, this shouldn't be a problem, but if you're very unlucky, this might expose previously unknown expose race conditions in your code.

**#Migration** This results in the following breaking changes:

API: `Signal.fromFuture` always emits asynchronously now, that is, it always starts with a None value (or the provided initial value), even if the future/promise has already resolved when it's observed (because there's absolutely no way to synchronously observe the content of a `js.Promise`).

`EventStream.fromFuture` does not offer the emitIfFutureCompleted option anymore, it is now always on. It also has a new option: emitOnce.

API: Internet Explorer 11 support now requires a `js.Promise` polyfill to use `fromFuture` methods, because Internet Explorer does not natively support JS Promises. See [stackoverflow](https://stackoverflow.com/questions/36016327/how-to-support-promises-in-internet-explorer-11).

API: Removed `SwitchFutureStrategy`, you can't directly flatten observables of futures anymore, because that behaviour isn't defined well enough.

  * **Migration:** When flattening observables of futures, wrap them in `EventStream.fromFuture` or `Signal.fromFuture` to make sure that you're getting what you expect. Then SwitchStreamStrategy or SwitchSignalStrategy will apply.

API: Disabled implicit conversions from Future and js.Promise to `Source`. They're not smooth / obvious enough to be implicit.

* **Migration**: same, doing it explicitly.

API: `fromFuture` methods require an implicit `ExecutionContext` now.

* **Migration:** Read [this explanation](https://www.scala-js.org/news/2021/12/10/announcing-scalajs-1.8.0/) by the Scala.js team, and choose which execution context you want to use.



## Minor Breaking Changes

**Migration** should be obvious for these. Most of these likely won't even affect you.

* `split` operator now provides signals only, no streams. This goes both for the return value of the operator and the argument type of the callback that it accepts.

* Remove `splitIntoSignals` method – use `split` (see above)

* Laminar node types like `ChildNode` don’t extend the corresponding `com.raquo.domtypes` types anymore (they were removed from domtypes)

* Some rarely used CSS style shorthands like `unicodeBidi.embed` were removed. Use regular strings to set the desired values, e.g. `unicodeBidi := “embed”`

* `DomApi.createHtmlElement` accepts `HtmlTag` now instead of `HtmlElement`. Similarly for `createSvgElement`.

* `Debugger` doesn't have `topoRank` field anymore (it was useless)

* Remove `Id[A] = A` type from `util` – define your own if you need it

* Remove hidden `Ref` util class – use the new `distinct*` methods

* Removed deprecated methods

* EventStream.periodic

  * `resetOnStop` default changed from `true` to `false` in accordance with new semantics

  * Removed `emitInitial `option. It's always `true` now. Use the new `drop(1, resetOnStop = true)` operator to approximate previous `emitInitial = false` behaviour.



## Changes Only Relevant To Extensions

**Migration:** These changes are only relevant to library authors and advanced users who extend Airstream and Laminar classes – the vast majority of regular end users are not affected by these changes.

* All `<X>EventStream` types were renamed to `<X>Stream`, except for `EventStream` itself and `DomEventStream`. The renamed types are not really user-facing except for `AjaxEventStream`, for which a deprecated alias is provided for now. You know what it feels like to have `<X>Stream.scala` and `<X>Signal.scala` files always next to each other when sorted alphabetically? Bliss.

* `Modifier` type moved from _Scala DOM Types_ to Laminar

* `Modifier`'s generic type param is constrained now, so you can’t use `Modifier[_]` won't compile anymore, use `Modifier.Base`.

* No more `SingleParentObservable`. Replace with `SingleParentSignal` and `SingleParentStream`

* `Splittable` now requires `empty`. `IdSplittable` is removed.

* Rename `Protected.maxParentTopoRank` to `Protected.maxTopoRank`

* Laminar `Key` types like `ReactiveProp`, `ReactiveHtmlAttr`, etc. were renamed to remove the “Reactive” prefix, and don’t extend the corresponding `com.raquo.domtypes` types anymore (those types were removed from _Scala DOM Types_)

* Laminar `Node` types like `ChildNode` don’t extend the corresponding `com.raquo.domtypes` types anymore (those types were removed from _Scala DOM Types_)

* `ReactiveHtmlElement` and `ReactiveSvgElement` now accept `ref` as a parameter. Use this wisely. Note that new helper methods are now available to inject foreign elements into Laminar tree (see above), so you shouldn’t need to use these constructors directly.

* `BaseObservable#equals` method now always compares observables by reference, and that's made `final`. In practice this means that creating case class subtypes of observables won’t accidentally break Airstream.



## Other Minor Changes

Fix: Debug logging does not wrap text in extraneous "Some()" and "None" anymore

Fix: Prevent text cursor from jumping to the end of the input in Safari when using the controlled-input pattern without using Laminar’s `controlled` method. ([#110](https://github.com/raquo/Laminar/issues/110))

API: You can now pass the two arguments to `controlled()`in reverse order too



## User-facing Renamings

**Migration:** find and rename these as they fail to compile

* Laminar `Key` types like `ReactiveProp`, `ReactiveHtmlAttr`, `ReactiveComplexHtmlKeys`, etc. were renamed to remove the “Reactive” prefix. `ReactiveStyle` was renamed to `StyleProp`.

* `content` style prop renamed to `contentCss` to avoid being shadowed by a common variable name.

* `EventStream.withCallback`, `withJsCallback`, `withObserver` → `withCallback`, `withJsCallback`, `withObserver`

* Observable operators:
  * `contramapOpt` → `contracollectOpt`
  * `foldLeft` and `foldLeftRecover` → `scanLeft` and `scanLeftRecover`

* Manual dynamic subscription factories require that you don't manually kill the `Subscription` that you create, that you let the resulting DynamicSubscription manage it. They were renamed and commented to reflect that:
  * `DynamicSubscription.apply` → `DynamicSubscription.unsafe`
  * `ReactiveElement.bindSubscription` → `ReactiveElement.bindSubscriptionUnsafe`

* `DomEventStreamPropBuilder` → `StreamEventPropBuilder`

* `customStyle` → `customStyleProp` (deprecated alias available)

* `KeyUpdater.$value` → `KeyUpdater.values`

* Debug API
  * `debugSpyInitialEval` → `debugSpyEvalFromParent`
  * `debugBreakInitialEval` → `debugBreakEvalFromParent`
  * `debugLogInitialEval` → `debugLogEvalFromParent`
  * `Debugger.onInitialEval` → `Debugger.onCurrentValueFromParent`






